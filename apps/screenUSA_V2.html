<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¸‚å ´ç¶œåˆå„€è¡¨æ¿</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
    <style>
        body {
            background-color: #2E2E2E;
            color: #E0E0E0;
        }
        .table {
            --bs-table-bg: #2E2E2E;
            --bs-table-color: #E0E0E0;
            --bs-table-border-color: #454545;
            --bs-table-striped-bg: #3A3A3A;
            --bs-table-hover-bg: #4A4A4A;
        }
        .btn-primary {
            background-color: #3A3A3A;
            border-color: #454545;
        }
        .positive { color: #50C878; }
        .negative { color: #FF5733; }
        .top-bg { background-color: rgba(80, 80, 30, 0.6); }
        .bottom-bg { background-color: rgba(80, 30, 30, 0.6); }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 2s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    </style>
</head>
<body>
    <div class="container mt-4">
        <h1>å¸‚å ´ç¶œåˆå„€è¡¨æ¿</h1>
        <div class="d-flex justify-content-between align-items-center mb-3">
            <div>
                <button id="run-button" class="btn btn-primary">ğŸš€ é–‹å§‹ç›£æ¸¬</button>
                <button id="export-button" class="btn btn-secondary" disabled>ğŸ“„ åŒ¯å‡ºè‡³ CSV</button>
            </div>
            <div id="status-container" class="d-flex align-items-center">
                <div class="loader" style="display: none;"></div>
                <span id="status-text">æº–å‚™å°±ç·’ã€‚</span>
            </div>
        </div>
        <table class="table table-striped table-hover">
            <thead id="table-head">
            </thead>
            <tbody id="table-body">
            </tbody>
        </table>
    </div>

    <script type="text/javascript">
        const runButton = document.getElementById('run-button');
        const exportButton = document.getElementById('export-button');
        const statusContainer = document.getElementById('status-container');
        const loader = statusContainer.querySelector('.loader');
        const statusText = document.getElementById('status-text');
        const tableHead = document.getElementById('table-head');
        const tableBody = document.getElementById('table-body');
        let currentData = [];

        function updateStatus(message, showLoader = false) {
            statusText.textContent = message;
            loader.style.display = showLoader ? 'inline-block' : 'none';
        }

        async function main() {
            updateStatus('æ­£åœ¨åˆå§‹åŒ– Pyodide...', true);
            let pyodide = await loadPyodide();
            updateStatus('Pyodide åˆå§‹åŒ–å®Œç•¢ã€‚æ­£åœ¨å®‰è£å‡½å¼åº«...', true);
            await pyodide.loadPackage(['micropip']);
            const micropip = pyodide.pkg_api.micropip;
            updateStatus('æ­£åœ¨å®‰è£ pandas...', true);
            await micropip.install(['pandas']);
            updateStatus('æ­£åœ¨å®‰è£ yfinance...', true);
            await micropip.install(['yfinance']);
            updateStatus('å‡½å¼åº«å®‰è£å®Œç•¢ã€‚', false);
            
            runButton.addEventListener('click', async () => {
                runButton.disabled = true;
                exportButton.disabled = true;
                updateStatus('æ­£åœ¨æŠ“å–æ•¸æ“š...', true);
                try {
                    pyodide.runPython(`
                        import pandas as pd
                        import numpy as np
                        from datetime import datetime, timedelta
                        import yfinance as yf
                        import js

                        CATEGORIZED_TICKERS = {
                            "å¤§ç›¤æŒ‡æ•¸": {
                                "æ¨™æ™®500æŒ‡æ•¸": "^GSPC", "ç´æ–¯é”å…‹æŒ‡æ•¸": "^IXIC", "é“ç“Šå·¥æ¥­æŒ‡æ•¸": "^DJI", "ç¾…ç´ 2000æŒ‡æ•¸": "^RUT",
                                "FAANG (ä¸ƒå·¨é ­)": "^NYFANG", "BTCæ¯”ç‰¹å¹£": "BTC-USD", "ETHä»¥å¤ªå¹£": "ETH-USD",
                            },
                            "ETFæŒ‡æ•¸": {
                                "æ¨™æ™®500 ETF (SPY)": "SPY", "ç´æ–¯é”å…‹100 ETF (QQQ)": "QQQ", "ç¾…ç´ 2000 ETF (IWM)": "IWM",
                                "ç¾…ç´ 1000åƒ¹å€¼ ETF (IWD)": "IWD", "ç¾…ç´ 1000æˆé•· ETF (IWF)": "IWF", "è¶¨å‹¢æ¿å¡Š ETF (MTUM)": "MTUM",
                            },
                            "å‚µå·èˆ‡è²¨å¹£": {
                                "20å¹´+ç¾å‚µETF": "TLT", "åƒåœ¾å‚µåˆ¸ETF": "HYG", "VIXææ…ŒæŒ‡æ•¸": "^VIX", "ç¾å…ƒæŒ‡æ•¸": "DX-Y.NYB",
                                "æ­å…ƒ/ç¾å…ƒ": "EURUSD=X", "è‹±éŠ/ç¾å…ƒ": "GBPUSD=X", "æ—¥åœ“/ç¾å…ƒ": "JPY=X", "å°å¹£/ç¾å…ƒ": "TWDUSD=X", "äººæ°‘å¹£/ç¾å…ƒ": "CNYUSD=X",
                            },
                            "æˆé•·å‹": {
                                "é€šè¨Šæœå‹™ (IXP)": "IXP", "åŠå°é«” (SOXX)": "SOXX", "AIç§‘æŠ€ETF (AIQ)": "AIQ",
                                "æ©Ÿå™¨äººèˆ‡AI ETF (BOTZ)": "BOTZ", "é‡å­è¨ˆç®—ETF (QTUM)": "QTUM", "ç§‘æŠ€ (XLK)": "XLK",
                                "å·¥æ¥­ (XLI)": "XLI", "åŸç‰©æ–™ (XLB)": "XLB", "éå¿…éœ€æ¶ˆè²»å“ (XLY)": "XLY"
                            },
                            "åƒ¹å€¼å‹": {
                                "èƒ½æº (XLE)": "XLE", "éŠ€è¡Œ (KBWB)": "KBWB", "å…¬ç”¨äº‹æ¥­ (XLU)": "XLU",
                                "æˆ¿åœ°ç”¢ (IYR)": "IYR", "å¿…éœ€æ¶ˆè²»å“ (XLP)": "XLP", "å¥åº·ç…§è­· (XLV)": "XLV", "ä¿éšª(IAK)":"IAK"
                            },
                            "å¤§å®—å•†å“": {
                                "é»ƒé‡‘æœŸè²¨": "GC=F", "ç™½éŠ€æœŸè²¨": "SI=F", "éŠ…æœŸè²¨": "HG=F", "WTIåŸæ²¹æœŸè²¨": "CL=F",
                                "å¤©ç„¶æ°£æœŸè²¨": "NG=F", "ç‰ç±³æœŸè²¨": "ZC=F", "é»ƒè±†æœŸè²¨": "ZS=F"
                            },
                            "å¤§å‹ç§‘æŠ€æ¬Šå€¼è‚¡ (Mega Cap)": {
                                "è˜‹æœ (AAPL)": "AAPL", "å¾®è»Ÿ (MSFT)": "MSFT", "è°·æ­Œ (GOOGL)": "GOOGL", "äºé¦¬éœ (AMZN)": "AMZN",
                                "è¼é” (NVDA)": "NVDA", "META (åŸFacebook)": "META", "ç¶²é£› (NFLX)": "NFLX",
                            },
                            "å…¶ä»–": {
                                "å°ç©é›» (TSM)": "TSM", "ç‰¹æ–¯æ‹‰ (TSLA)": "TSLA", "è‹±ç‰¹çˆ¾ (INTC)": "INTC", "é«˜é€š (QCOM)": "QCOM",
                                "AMD (è¶…å¾®)": "AMD", "åšé€š (AVGO)": "AVGO", "ç¾å…‰ (MU)": "MU", "ASML (è·è˜­æ™¶åœ“å» )": "ASML",
                                "Adobe (ADBE)": "ADBE", "Salesforce (CRM)": "CRM", "UNH (è¯åˆå¥åº·)": "UNH", "Visa (V)": "V",
                            }
                        }

                        def get_all_tickers(categorized_tickers):
                            return [ticker for category in categorized_tickers.values() for ticker in category.values()]

                        def calc_rsi(series, period=14):
                            delta = series.diff()
                            gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
                            loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
                            rs = gain / loss
                            rsi = 100 - (100 / (1 + rs))
                            return rsi

                        def fetch_data():
                            tickers = get_all_tickers(CATEGORIZED_TICKERS)
                            js.updateStatus(f"ğŸ” æ­£åœ¨æŠ“å– {len(tickers)} å€‹æ¨™çš„çš„æ¯æ—¥æ•¸æ“š...", True)
                            today = datetime.now()
                            start_of_last_year = today.replace(year=today.year - 1, month=1, day=1)
                            start_str = start_of_last_year.strftime('%Y-%m-%d')
                            end_str = (today + timedelta(days=1)).strftime('%Y-%m-%d')
                            
                            daily_data = yf.download(tickers, start=start_str, end=end_str, group_by='ticker', auto_adjust=True)
                            js.updateStatus("ğŸ” æ•¸æ“šä¸‹è¼‰å®Œç•¢ï¼Œæ­£åœ¨é€²è¡Œè¨ˆç®—...", True)
                            
                            results = []
                            reverse_ticker_map = {v: k for category in CATEGORIZED_TICKERS.values() for k, v in category.items()}
                            last_day_of_last_year = today.replace(year=today.year - 1, month=12, day=31)

                            for ticker in tickers:
                                if ticker not in daily_data.columns.levels[0]: continue
                                hist = daily_data[ticker].dropna()
                                if len(hist) < 15: continue
                                
                                last_price = hist['Close'].iloc[-1]
                                day_change = (last_price / hist['Close'].iloc[-2] - 1) * 100 if len(hist['Close']) > 1 else 0
                                price_7_days_ago = hist['Close'].asof(today - timedelta(days=7))
                                week_change = (last_price / price_7_days_ago - 1) * 100 if price_7_days_ago else 0
                                price_30_days_ago = hist['Close'].asof(today - timedelta(days=30))
                                month_change = (last_price / price_30_days_ago - 1) * 100 if price_30_days_ago else 0
                                price_ytd_start = hist['Close'].asof(last_day_of_last_year)
                                ytd_change = (last_price / price_ytd_start - 1) * 100 if price_ytd_start else 0
                                rsi = calc_rsi(hist['Close']).iloc[-1]
                                name = reverse_ticker_map.get(ticker, ticker)
                                
                                results.append({
                                    "ticker": ticker, "name": name, "price": last_price,
                                    "day": day_change, "week": week_change, "month": month_change, "ytd": ytd_change,
                                    "rsi": rsi
                                })
                            
                            df = pd.DataFrame(results)
                            rankings = {col: {'top3': df.nlargest(3, col)['ticker'].tolist(), 'bottom3': df.nsmallest(3, col)['ticker'].tolist()}
                                        for col in ['day', 'week', 'month', 'ytd']}
                            
                            return pd.Series({'data': df.to_json(orient='records'), 'rankings': rankings}).to_json()

                        data_json = fetch_data()
                        CATEGORIZED_TICKERS_py = dict(CATEGORIZED_TICKERS)
                    `);
                    const result = JSON.parse(pyodide.globals.get('data_json'));
                    currentData = JSON.parse(result.data);
                    const rankings = result.rankings;
                    const categorized_tickers = pyodide.globals.get('CATEGORIZED_TICKERS_py').toJs();
                    renderTable(currentData, categorized_tickers, rankings);
                    updateStatus('âœ… æ•¸æ“šæ›´æ–°å®Œç•¢ï¼', false);
                    exportButton.disabled = false;
                } catch (error) {
                    console.error(error);
                    updateStatus(`âŒ ç™¼ç”ŸéŒ¯èª¤: ${error.message}`, false);
                } finally {
                    runButton.disabled = false;
                }
            });

            exportButton.addEventListener('click', () => {
                exportToCSV(currentData);
            });
        }

        function exportToCSV(data) {
            const headers = ["ç›£æ¸¬æ¨™çš„", "ç›®å‰åƒ¹ä½", "1å¤© (%)", "1é€± (%)", "1å€‹æœˆ (%)", "YTD (%)", "RSI(14)"];
            const csvRows = [headers.join(',')];
            for (const row of data) {
                const values = [row.name, row.price, row.day, row.week, row.month, row.ytd, row.rsi];
                csvRows.push(values.join(','));
            }
            const csvString = csvRows.join('\n');
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'market_data.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function renderTable(data, categorized_tickers, rankings) {
            tableHead.innerHTML = `
                <tr>
                    <th>ç›£æ¸¬æ¨™çš„</th>
                    <th>ç›®å‰åƒ¹ä½</th>
                    <th>1å¤© (%)</th>
                    <th>1é€± (%)</th>
                    <th>1å€‹æœˆ (%)</th>
                    <th>YTD (%)</th>
                    <th>RSI(14)</th>
                </tr>
            `;
            tableBody.innerHTML = '';

            const dataMap = new Map(data.map(item => [item.ticker, item]));

            for (const [category, tickers] of categorized_tickers) {
                const categoryRow = document.createElement('tr');
                categoryRow.innerHTML = `<td colspan="7" class="fw-bold">â–¼ ${category}</td>`;
                categoryRow.style.backgroundColor = '#4A4A4A';
                tableBody.appendChild(categoryRow);

                for (const [name, ticker] of Object.entries(tickers)) {
                    const rowData = dataMap.get(ticker);
                    if (rowData) {
                        const tr = document.createElement('tr');
                        
                        const nameCell = document.createElement('td');
                        nameCell.textContent = rowData.name;
                        tr.appendChild(nameCell);

                        const priceCell = document.createElement('td');
                        priceCell.textContent = rowData.price.toFixed(4);
                        tr.appendChild(priceCell);

                        ['day', 'week', 'month', 'ytd'].forEach(key => {
                            const cell = document.createElement('td');
                            cell.textContent = rowData[key].toFixed(2);
                            cell.className = rowData[key] >= 0 ? 'positive' : 'negative';
                            if (rankings[key]['top3'].includes(ticker)) {
                                cell.classList.add('top-bg');
                            }
                            if (rankings[key]['bottom3'].includes(ticker)) {
                                cell.classList.add('bottom-bg');
                            }
                            tr.appendChild(cell);
                        });

                        const rsiCell = document.createElement('td');
                        rsiCell.textContent = rowData.rsi.toFixed(2);
                        tr.appendChild(rsiCell);

                        tableBody.appendChild(tr);
                    }
                }
            }
        }

        main();
    </script>
</body>
</html>
